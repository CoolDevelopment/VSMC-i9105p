/*****************************************************************************
* Copyright 2003 - 2011 Broadcom Corporation.  All rights reserved.
*
* Unless you and Broadcom execute a separate written software license
* agreement governing use of this software, this software is licensed to you
* under the terms of the GNU General Public License version 2, available at
* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
*
* Notwithstanding the above, under no circumstances may you combine this
* software in any way with any other Broadcom software provided under a
* license other than the GPL, without Broadcom's express prior written
* consent.
*****************************************************************************/

/*
 * A board template for adding devices and pass their associated board
 * dependent confgiurations as platform_data into the drivers
 *
 * This file needs to be included by the board specific source code
 */

#include <linux/init.h>
#include <linux/dma-mapping.h>
#include <linux/serial_8250.h>
#include <linux/i2c.h>
#include <linux/i2c-kona.h>

#include <asm/memory.h>
#include <asm/sizes.h>
#include <linux/io.h>
#include <linux/gpio.h>
#include <asm/hardware/gic.h>
#include <asm/mach-types.h>
#include <asm/mach/arch.h>
#include <asm/mach/map.h>

#include <mach/hardware.h>
#include <mach/irqs.h>
#include <mach/kona.h>
#include <mach/dma_mmap.h>
#include <mach/sdma.h>
#include <mach/memc_qos.h>
#include <mach/sdio_platform.h>
#include <mach/usbh_cfg.h>
#include <mach/halaudio_audioh_platform.h>
#include <mach/halaudio_pcm_platform.h>

#include <sdio_settings.h>

#include <i2c_settings.h>
#include <usbh_settings.h>

#include <halaudio_settings.h>
#include <halaudio_audioh_settings.h>
#include <halaudio_pcm_settings.h>

#if defined(CONFIG_BACKLIGHT_PWM) || defined(CONFIG_BACKLIGHT_PWM_MODULE)
#include <linux/pwm_backlight.h>
#include <pwm_backlight_settings.h>
#endif

#if defined(CONFIG_BCM_RFKILL) || defined(CONFIG_BCM_RFKILL_MODULE)
#include <linux/broadcom/bcmbt_rfkill.h>
#include <bcmbt_rfkill_settings.h>
#endif

#if defined(CONFIG_BCM_LPM_LDISC) || defined(CONFIG_BCM_LPM_LDISC_MODULE)
#include <linux/broadcom/bcmbt_lpm_ldisc.h>
#include <bcmbt_lpm_settings.h>
#endif

#if defined(CONFIG_TOUCHSCREEN_EGALAX_I2C) || defined(CONFIG_TOUCHSCREEN_EGALAX_I2C_MODULE)
#include <linux/i2c/egalax_i2c_ts.h>
#include <egalax_i2c_ts_settings.h>
#endif

#if defined(CONFIG_SENSORS_BMA150) || defined(CONFIG_SENSORS_BMA150_MODULE)
#include <linux/bma150.h>
#include <sensors_bma150_i2c_settings.h>
#endif

#if defined(CONFIG_SENSORS_BH1715) || defined(CONFIG_SENSORS_BH1715_MODULE)
#include <linux/bh1715.h>
#include <bh1715_i2c_settings.h>
#endif

#if defined(CONFIG_SENSORS_MPU3050) || defined(CONFIG_SENSORS_MPU3050_MODULE)
#include <linux/mpu3050.h>
#include <mpu3050_i2c_settings.h>
#endif

#if defined(CONFIG_MPU_SENSORS_MPU6050B1) || defined(CONFIG_MPU_SENSORS_MPU6050B1_MODULE)
#include <linux/mpu.h>
#include <linux/mpu6050b1.h>
#include <linux/brcm_axis_change.h>
#include <mpu6050_settings.h>
#endif

#if defined(CONFIG_BMP18X_I2C) || defined(CONFIG_BMP18X_I2C_MODULE)
#include <linux/bmp18x.h>
#include <bmp18x_i2c_settings.h>
#endif

#if defined(CONFIG_SENSORS_AK8975) || defined(CONFIG_SENSORS_AK8975_MODULE)
#include <linux/akm8975.h>
#include <akm8975_i2c_settings.h>
#endif

#if defined(CONFIG_SENSORS_AK8975_BRCM) || defined(CONFIG_SENSORS_AK8975_BRCM_MODULE)
#include <linux/akm8975_brcm.h>
#include <akm8975_i2c_settings.h>
#endif

#if defined(CONFIG_NET_ISLAND)
#include <mach/net_platform.h>
#include <net_settings.h>
#endif

#if defined(CONFIG_MAX3353) || defined(CONFIG_MAX3353_MODULE)
#include <otg_settings.h>
#include <linux/i2c/max3353.h>
#endif

#if defined(CONFIG_LEDS_GPIO) || defined(CONFIG_LEDS_GPIO_MODULE)
#include <leds_gpio_settings.h>
#include <linux/leds.h>
#endif

#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
#include <linux/input.h>
#include <linux/gpio_keys.h>
#include <gpio_keys_settings.h>
#endif

#if defined(CONFIG_KONA_VCHIQ) || defined(CONFIG_KONA_VCHIQ_MODULE)
#include <mach/io_map.h>
#include <mach/aram_layout.h>

#include <linux/broadcom/vchiq_platform_data_kona.h>
#include <linux/broadcom/vchiq_platform_data_memdrv_kona.h>
#endif

#if defined(CONFIG_KEYBOARD_KONA) || defined(CONFIG_KEYBOARD_KONA_MODULE)
#include <linux/kona_keypad.h>
#include <keymap_settings.h>
#endif

#if defined(CONFIG_MONITOR_ADC121C021_I2C)  || defined(CONFIG_MONITOR_ADC121C021_I2C_MODULE)
#include <linux/broadcom/adc121c021_driver.h>
#include <adc121c021_settings.h>
#include <battery_settings.h>
#endif

#if defined(CONFIG_MONITOR_BQ27541_I2C) || defined(CONFIG_MONITOR_BQ27541_I2C_MODULE)
#include <linux/broadcom/bq27541.h>
#include <bq27541_i2c_settings.h>
#endif

#if defined(CONFIG_BATTERY_MAX17040) || defined(CONFIG_BATTERY_MAX17040_MODULE)
#include <linux/max17040_battery.h>
#include <max17040_settings.h>
#endif

#if defined(CONFIG_BCM_CMP_BATTERY_MULTI) || defined(CONFIG_BCM_CMP_BATTERY_MULTI_MODULE)
#include <linux/broadcom/cmp_battery_multi.h>
#include <battery_settings.h>
#endif

#if defined(CONFIG_BCM_CMP_BATTERY_BQ24616) || defined(CONFIG_BCM_CMP_BATTERY_BQ24616_MODULE)
#include <linux/broadcom/cmp_battery_bq24616.h>
#include <battery_settings.h>
/* Until proper solution for docking station is found, cp docking station is
   handled in bq24616 battery driver */
#include <dock_settings.h>
#endif

#if defined(CONFIG_BCM_GPS) || defined(CONFIG_BCM_GPS_MODULE)
#include <gps_settings.h>
#include <linux/broadcom/gps.h>
#endif

#if defined(CONFIG_BCM_HAPTICS) || defined(CONFIG_BCM_HAPTICS_MODULE)
#include <linux/broadcom/bcm_haptics.h>
#include <bcm_haptics_settings.h>
#endif

#if defined(CONFIG_BCM_HEADSET_SW)
#include <linux/broadcom/headset_cfg.h>
#include <headset_settings.h>
#endif

#if defined(CONFIG_BCM_HDMI_DET) || defined(CONFIG_BCM_HDMI_DET_MODULE)
#include <linux/broadcom/hdmi_cfg.h>
#include <hdmi_settings.h>
#endif

#if defined(CONFIG_TFT_PANEL) || defined(CONFIG_TFT_PANEL_MODULE)
#include <linux/broadcom/tft_panel.h>
#include <tft_panel_settings.h>
#endif


#include "island.h"
#include "common.h"

#ifndef ISLAND_BOARD_ID
#error ISLAND_BOARD_ID needs to be defined in board_xxx.c
#endif

/*
 * Since this board template is included by each board_xxx.c. We concatenate
 * ISLAND_BOARD_ID to help debugging when multiple boards are compiled into
 * a single image
 */
#define concatenate_again(a, b) a ## b
#define concatenate(a, b) concatenate_again(a, b)

/* number of SDIO devices */
#define MAX_SDIO_DEVICES      3

/*
 * The SDIO index starts from 1 in CHAL, which is really not by convention
 * Re-define them here to avoid confusions
 */
#define PHYS_ADDR_SDIO0        SDIO1_BASE_ADDR
#define PHYS_ADDR_SDIO1        SDIO2_BASE_ADDR
#define PHYS_ADDR_SDIO2        SDIO3_BASE_ADDR
#define SDIO_CORE_REG_SIZE     0x10000


/* number of I2C adapters (hosts/masters) */
#define MAX_I2C_ADAPS    3

/*
 * The BSC (I2C) index starts from 1 in CHAL, which is really not by
 * convention. Re-define them here to avoid confusions
 */
#define PHYS_ADDR_BSC0         BSC1_BASE_ADDR
#define PHYS_ADDR_BSC1         BSC2_BASE_ADDR
#define PHYS_ADDR_BSC2         PMU_BSC_BASE_ADDR
#define BSC_CORE_REG_SIZE      0x100

#define USBH_EHCI_CORE_REG_SIZE    0x90
#define USBH_OHCI_CORE_REG_SIZE    0x1000
#define USBH_DWC_REG_OFFSET        USBH_EHCI_CORE_REG_SIZE
#define USBH_DWC_BASE_ADDR         (EHCI_BASE_ADDR + USBH_DWC_REG_OFFSET)
#define USBH_DWC_CORE_REG_SIZE     0x20
#define USBH_CTRL_REG_OFFSET       0x8000
#define USBH_CTRL_BASE_ADDR        (EHCI_BASE_ADDR + USBH_CTRL_REG_OFFSET)
#define USBH_CTRL_CORE_REG_SIZE    0x20

#define OTG_CTRL_CORE_REG_SIZE     0x100

#if defined(CONFIG_BACKLIGHT_PWM) || defined(CONFIG_BACKLIGHT_PWM_MODULE)
static struct platform_pwm_backlight_data pwm_backlight_data =
#ifdef HW_PWM_BACKLIGHT_PARAM
	HW_PWM_BACKLIGHT_PARAM;
#else /* use default setting here */
{
	.pwm_name	= "kona_pwmc:2",
	.max_brightness	= 255,
	.dft_brightness	= 255,
	.pwm_period_ns	= 5000000,
	.polarity = 1,
};
#endif

static struct platform_device pwm_backlight_device = {
	.name     = "pwm-backlight",
	.id       = -1,
	.dev      = {
		.platform_data = &pwm_backlight_data,
	},
};
#endif

static struct resource sdio0_resource[] = {
	[0] = {
		.start = PHYS_ADDR_SDIO0,
		.end = PHYS_ADDR_SDIO0 + SDIO_CORE_REG_SIZE - 1,
		.flags = IORESOURCE_MEM,
	},
	[1] = {
		.start = BCM_INT_ID_SDIO0,
		.end = BCM_INT_ID_SDIO0,
		.flags = IORESOURCE_IRQ,
	},
};

static struct resource sdio1_resource[] = {
	[0] = {
		.start = PHYS_ADDR_SDIO1,
		.end = PHYS_ADDR_SDIO1 + SDIO_CORE_REG_SIZE - 1,
		.flags = IORESOURCE_MEM,
	},
	[1] = {
		.start = BCM_INT_ID_SDIO1,
		.end = BCM_INT_ID_SDIO1,
		.flags = IORESOURCE_IRQ,
	},
};

static struct resource sdio2_resource[] = {
	[0] = {
		.start = PHYS_ADDR_SDIO2,
		.end = PHYS_ADDR_SDIO2 + SDIO_CORE_REG_SIZE - 1,
		.flags = IORESOURCE_MEM,
	},
	[1] = {
		.start = BCM_INT_ID_SDIO_NAND,
		.end = BCM_INT_ID_SDIO_NAND,
		.flags = IORESOURCE_IRQ,
	},
};

static struct sdio_platform_cfg sdio_param[] =
#ifdef HW_SDIO_PARAM
	HW_SDIO_PARAM;
#else
	{};
#endif

static struct platform_device sdio_devices[MAX_SDIO_DEVICES] = {
	{ /* SDIO0 */
		.name = "sdhci",
		.id = 0,
		.resource = sdio0_resource,
		.num_resources	= ARRAY_SIZE(sdio0_resource),
	},
	{ /* SDIO1 */
		.name = "sdhci",
		.id = 1,
		.resource = sdio1_resource,
		.num_resources	= ARRAY_SIZE(sdio1_resource),
	},
	{ /* SDIO2 */
		.name = "sdhci",
		.id = 2,
		.resource = sdio2_resource,
		.num_resources    = ARRAY_SIZE(sdio2_resource),
	},
};

#if defined(CONFIG_NET_ISLAND)
static struct island_net_hw_cfg island_net_data =
#ifdef HW_CFG_ISLAND_NET
	HW_CFG_ISLAND_NET;
#else
{
	.addrPhy0 = 0,
	.addrPhy1 = 1,
	.gpioPhy0 = -1,
	.gpioPhy1 = -1,
};
#endif

static struct platform_device net_device = {
	.name = "island-net",
	.id = -1,
	.dev = {
		.platform_data = &island_net_data,
	},
};
#endif /* CONFIG_NET_ISLAND */

static struct bsc_adap_cfg i2c_adap_param[] =
#ifdef HW_I2C_ADAP_PARAM
	HW_I2C_ADAP_PARAM;
#else
	{};
#endif

static struct resource i2c0_resource[] = {
	[0] = {
		.start = PHYS_ADDR_BSC0,
		.end = PHYS_ADDR_BSC0 + BSC_CORE_REG_SIZE - 1,
		.flags = IORESOURCE_MEM,
	},
	[1] = {
		.start = BCM_INT_ID_I2C0,
		.end = BCM_INT_ID_I2C0,
		.flags = IORESOURCE_IRQ,
	},
};

static struct resource i2c1_resource[] = {
	[0] = {
		.start = PHYS_ADDR_BSC1,
		.end = PHYS_ADDR_BSC1 + BSC_CORE_REG_SIZE - 1,
		.flags = IORESOURCE_MEM,
	},
	[1] = {
		.start = BCM_INT_ID_I2C1,
		.end = BCM_INT_ID_I2C1,
		.flags = IORESOURCE_IRQ,
	},
};

static struct resource i2c2_resource[] = {
	[0] = {
		.start = PHYS_ADDR_BSC2,
		.end = PHYS_ADDR_BSC2 + BSC_CORE_REG_SIZE - 1,
		.flags = IORESOURCE_MEM,
	},
	[1] = {
		.start = BCM_INT_ID_PM_I2C,
		.end = BCM_INT_ID_PM_I2C,
		.flags = IORESOURCE_IRQ,
	},
};

static struct platform_device i2c_adap_devices[MAX_I2C_ADAPS] = {
	{  /* for BSC0 */
		.name = "bsc-i2c",
		.id = 0,
		.resource = i2c0_resource,
		.num_resources	= ARRAY_SIZE(i2c0_resource),
	},
	{  /* for BSC1 */
		.name = "bsc-i2c",
		.id = 1,
		.resource = i2c1_resource,
		.num_resources	= ARRAY_SIZE(i2c1_resource),
	},
	{  /* for PMBSC */
		.name = "bsc-i2c",
		.id = 2,
		.resource = i2c2_resource,
		.num_resources	= ARRAY_SIZE(i2c2_resource),
	},
};

#ifdef CONFIG_BCM_HEADSET_SW

#define board_headsetdet_data concatenate(ISLAND_BOARD_ID, _headsetdet_data)
static struct headset_hw_cfg board_headsetdet_data =
#ifdef HW_CFG_HEADSET
	HW_CFG_HEADSET;
#else
{
	.gpio_headset_det = -1,
	.gpio_headset_active_low = 0,
	.gpio_mic_det = -1,
	.gpio_mic_active_low = 0,
};
#endif

#define board_headsetdet_device concatenate(ISLAND_BOARD_ID, _headsetdet_device)
static struct platform_device board_headsetdet_device = {
	.name = "bcm-headset-det",
	.id = -1,
	.dev = {
		.platform_data = &board_headsetdet_data,
	},
};

#define board_add_headsetdet_device concatenate(ISLAND_BOARD_ID, _add_headsetdet_device)
static void __init board_add_headsetdet_device(void)
{
	platform_device_register(&board_headsetdet_device);
}

#endif /* CONFIG_BCM_HEADSET_SW */

#if defined(CONFIG_BCM_HDMI_DET) || defined(CONFIG_BCM_HDMI_DET_MODULE)

#define board_hdmidet_data concatenate(ISLAND_BOARD_ID, _hdmidet_data)
static struct hdmi_hw_cfg board_hdmidet_data =
#ifdef HW_CFG_HDMI
	HW_CFG_HDMI;
#else
{
	.gpio_hdmi_det = -1,
};
#endif

#define board_hdmidet_device concatenate(ISLAND_BOARD_ID, _hdmidet_device)
static struct platform_device board_hdmidet_device = {
	.name = "hdmi-detect",
	.id = -1,
	.dev = {
		.platform_data = &board_hdmidet_data,
	},
};

#define board_add_hdmidet_device concatenate(ISLAND_BOARD_ID, _add_hdmidet_device)
static void __init board_add_hdmidet_device(void)
{
	platform_device_register(&board_hdmidet_device);
}

#endif /* #if defined(CONFIG_BCM_HDMI_DET) || defined(CONFIG_BCM_HDMI_DET_MODULE) */

#if defined(CONFIG_TFT_PANEL) || defined(CONFIG_TFT_PANEL_MODULE)
#define board_tft_panel_data concatenate(ISLAND_BOARD_ID, _tft_panel_data)
static struct tft_panel_platform_data board_tft_panel_data = TFT_PANEL_SETTINGS;

#define board_tft_panel_device concatenate(ISLAND_BOARD_ID, _tft_panel_device)
static struct platform_device board_tft_panel_device = {
	.name = TFT_PANEL_DRIVER_NAME,
	.id = -1,
	.dev = {
		.platform_data = &board_tft_panel_data,
	},
};

#define board_add_tft_panel_device concatenate(ISLAND_BOARD_ID, _add_tft_panel_device)
static void __init board_add_tft_panel_device(void)
{
	platform_device_register(&board_tft_panel_device);
}
#endif

static struct usbh_cfg usbh_param =
#ifdef HW_USBH_PARAM
	HW_USBH_PARAM;
#else
	{};
#endif

static struct resource usbh_resource[] = {
	[0] = {
		.start = USBH_CTRL_BASE_ADDR,
		.end = USBH_CTRL_BASE_ADDR + USBH_CTRL_CORE_REG_SIZE - 1,
		.flags = IORESOURCE_MEM,
	},
};

static struct platform_device usbh_device = {
	.name = "usbh",
	.id = -1,
	.resource = usbh_resource,
	.num_resources = ARRAY_SIZE(usbh_resource),
	.dev = {
		.platform_data = &usbh_param,
	},
};

static u64 ehci_dmamask = DMA_BIT_MASK(32);

static struct resource usbh_ehci_resource[] = {
	[0] = {
		.start = EHCI_BASE_ADDR,
		.end = EHCI_BASE_ADDR + USBH_EHCI_CORE_REG_SIZE - 1,
		.flags = IORESOURCE_MEM,
	},
	[1] = {
		.start = BCM_INT_ID_ULPI_EHCI,
		.end = BCM_INT_ID_ULPI_EHCI,
		.flags = IORESOURCE_IRQ,
	},
};

static struct platform_device usbh_ehci_device = {
	.name = "bcm-ehci",
	.id = 0,
	.resource = usbh_ehci_resource,
	.num_resources = ARRAY_SIZE(usbh_ehci_resource),
	.dev = {
		.dma_mask = &ehci_dmamask,
		.coherent_dma_mask = DMA_BIT_MASK(32),
	},
};

static u64 ohci_dmamask = DMA_BIT_MASK(32);

static struct resource usbh_ohci_resource[] = {
	[0] = {
		.start = OHCI_BASE_ADDR,
		.end = OHCI_BASE_ADDR + USBH_OHCI_CORE_REG_SIZE - 1,
		.flags = IORESOURCE_MEM,
	},
	[1] = {
		.start = BCM_INT_ID_ULPI_OHCI,
		.end = BCM_INT_ID_ULPI_OHCI,
		.flags = IORESOURCE_IRQ,
	},
};

static struct platform_device usbh_ohci_device = {
	.name = "bcm-ohci",
	.id = 0,
	.resource = usbh_ohci_resource,
	.num_resources = ARRAY_SIZE(usbh_ohci_resource),
	.dev = {
		.dma_mask = &ohci_dmamask,
		.coherent_dma_mask = DMA_BIT_MASK(32),
	},
};

#if defined(CONFIG_TOUCHSCREEN_EGALAX_I2C) || defined(CONFIG_TOUCHSCREEN_EGALAX_I2C_MODULE)
static struct egalax_i2c_ts_cfg egalax_i2c_param = {
	.id = -1,
	.gpio = {
		.reset = -1,
		.event = -1,
	},
};

static struct i2c_board_info egalax_i2c_boardinfo[] = {
	{
		.type = "egalax_i2c",
		.addr = 0x04,
		.platform_data = &egalax_i2c_param,
	},
};
#endif

#if defined(CONFIG_MAX3353) || defined(CONFIG_MAX3353_MODULE)
static struct max3353_platform_data max3353_info = {
	.mode = HW_OTG_MAX3353_MODE,
};

static struct i2c_board_info max3353_i2c_boardinfo[] = {
	{
		I2C_BOARD_INFO(MAX3353_DRIVER_NAME, MAX3353_I2C_ADDR_BASE),
		.platform_data  = &max3353_info,
	},
};
#endif

#if defined(CONFIG_LEDS_GPIO) || defined(CONFIG_LEDS_GPIO_MODULE)
#define board_gpio_leds concatenate(ISLAND_BOARD_ID, _board_gpio_leds)
static struct gpio_led board_gpio_leds[] = GPIO_LEDS_SETTINGS;

#define leds_gpio_data concatenate(ISLAND_BOARD_ID, _leds_gpio_data)
static struct gpio_led_platform_data leds_gpio_data = {
	.num_leds = ARRAY_SIZE(board_gpio_leds),
	.leds = board_gpio_leds,
};

#define board_leds_gpio_device concatenate(ISLAND_BOARD_ID, _leds_gpio_device)
static struct platform_device board_leds_gpio_device = {
	.name = "leds-gpio",
	.id = -1,
	.dev = {
		.platform_data = &leds_gpio_data,
	},
};
#endif

#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
#define board_gpio_keys concatenate(ISLAND_BOARD_ID, _board_gpio_keys)
static struct gpio_keys_button board_gpio_keys[] = GPIO_KEYS_SETTINGS;

#define gpio_keys_data concatenate(ISLAND_BOARD_ID, _gpio_keys_data)
static struct gpio_keys_platform_data gpio_keys_data = {
	.nbuttons = ARRAY_SIZE(board_gpio_keys),
	.buttons = board_gpio_keys,
};

#define board_gpio_keys_device concatenate(ISLAND_BOARD_ID, _gpio_keys_device)
static struct platform_device board_gpio_keys_device = {
	.name = "gpio-keys",
	.id = -1,
	.dev = {
		.platform_data = &gpio_keys_data,
	},
};
#endif

#if defined(CONFIG_KEYBOARD_KONA) || defined(CONFIG_KEYBOARD_KONA_MODULE)

#define board_keypad_keymap concatenate(ISLAND_BOARD_ID, _keypad_keymap)
static struct KEYMAP board_keypad_keymap[] = HW_DEFAULT_KEYMAP;

#define board_keypad_pwroff concatenate(ISLAND_BOARD_ID, _keypad_pwroff)
static unsigned int board_keypad_pwroff[] = HW_DEFAULT_POWEROFF;

#define board_keypad_param concatenate(ISLAND_BOARD_ID, _keypad_param)
static struct KEYPAD_DATA board_keypad_param = {
	.active_mode = 0,
	.keymap      = board_keypad_keymap,
	.keymap_cnt  = ARRAY_SIZE(board_keypad_keymap),
	.pwroff      = board_keypad_pwroff,
	.pwroff_cnt  = ARRAY_SIZE(board_keypad_pwroff),
	.clock       = "gpiokp_apb_clk",
};

#define board_keypad_device_resource concatenate(ISLAND_BOARD_ID, _keypad_device_resource)
static struct resource board_keypad_device_resource[] = {
	[0] = {
		.start = KEYPAD_BASE_ADDR,
		.end   = KEYPAD_BASE_ADDR + 0xD0,
		.flags = IORESOURCE_MEM,
	},
	[1] = {
		.start = BCM_INT_ID_KEYPAD,
		.end   = BCM_INT_ID_KEYPAD,
		.flags = IORESOURCE_IRQ,
	},
};

#define board_keypad_device concatenate(ISLAND_BOARD_ID, _keypad_device)
static struct platform_device board_keypad_device = {
	.name          = "kona_keypad",
	.id            = -1,
	.resource      = board_keypad_device_resource,
	.num_resources = ARRAY_SIZE(board_keypad_device_resource),
	.dev = {
		.platform_data = &board_keypad_param,
	},
};
#endif

#if defined(CONFIG_BCM_GPS) || defined(CONFIG_BCM_GPS_MODULE)
#define board_hana_gps_info concatenate(ISLAND_BOARD_ID, _board_hana_gps_info)
static struct gps_platform_data board_hana_gps_info = GPS_PLATFORM_DATA_SETTINGS;

#define platform_device_gps concatenate(ISLAND_BOARD_ID, _platform_device_gps)
static struct platform_device platform_device_gps = {
	.name = "gps",
	.id = -1,
	.dev = {
		.platform_data = &board_hana_gps_info,
	},
};
#endif

#if defined(CONFIG_BCM_HAPTICS) || defined(CONFIG_BCM_HAPTICS_MODULE)
#define board_bcm_haptics_device concatenate(ISLAND_BOARD_ID, _bcm_haptics_device)

#define board_bcm_haptics_data concatenate(ISLAND_BOARD_ID, _board_bcm_haptics_data)
static struct bcm_haptics_data board_bcm_haptics_data = BCM_HAPTICS_SETTINGS;

static struct platform_device board_bcm_haptics_device = {
	.name = BCM_HAPTICS_DRIVER_NAME,
	.id = -1,
	.dev = {
		.platform_data = &board_bcm_haptics_data,
	},
};
#endif

#if defined(CONFIG_KONA_OTG_CP) || defined(CONFIG_KONA_OTG_CP_MODULE)
static struct resource otg_cp_resource[] = {
	[0] = {
		.start = HSOTG_CTRL_BASE_ADDR,
		.end = HSOTG_CTRL_BASE_ADDR + OTG_CTRL_CORE_REG_SIZE - 1,
		.flags = IORESOURCE_MEM,
	},
	[1] = {
		.start = BCM_INT_ID_USB_OTG_DRV_VBUS,
		.end = BCM_INT_ID_USB_OTG_DRV_VBUS,
		.flags = IORESOURCE_IRQ,
	},
};

static struct platform_device otg_cp_device = {
	.name = "kona-otg-cp",
	.id = -1,
	.resource = otg_cp_resource,
	.num_resources = ARRAY_SIZE(otg_cp_resource),
};
#endif

#if defined(CONFIG_KONA_VCHIQ) || defined(CONFIG_KONA_VCHIQ_MODULE)

/****************************************************************************
*
*   VCEB display device
*
***************************************************************************/

#if defined(CONFIG_VC_VCHIQ_MEMDRV_KONA) || defined(CONFIG_VC_VCHIQ_MEMDRV_KONA_MODULE) \
 || defined(CONFIG_VC_VCHIQ_BUSDRV_SHAREDMEM) || defined(CONFIG_VC_VCHIQ_BUSDRV_SHAREDMEM_MODULE)

/* Internal videocore is defined - Assume that it's for display */

#define  VCEB_DISPLAY_DEVICE

static VCEB_PLATFORM_DATA_KONA_T vceb_kona_display_data = {
	.create_params = {
		.instance_name   = "display",
		.videocore_param = "vca",
		.host_param      = &vceb_kona_display_data,
	},

	.vcMemAddr         = VC_EMI,
	.vcSramAddr        = KONA_INT_SRAM_BASE + BCMHANA_ARAM_VC_OFFSET,

	.bootFromKernel    = 1,
#if 0
	/*
	 * commenting out for the time being since
	 * GPIO mux group is hardcoded for the time being
	 */
	.gpiomux_lcd_group = gpiomux_group_vc_dpi_rgb,
	.gpiomux_lcd_id    = 0,
	.gpiomux_lcd_label = "vc-lcd",

	.gpiomux_jtag_group = gpiomux_group_vc_jtag,
	.gpiomux_jtag_id    = 0,
	.gpiomux_jtag_label = "vc-jtag",
#endif
};

static struct platform_device vceb_display_device = {
	.name = "vceb_kona",
	.id = 0,
	.dev = {
		.platform_data = &vceb_kona_display_data,
	},
};

#endif
/****************************************************************************
*
*   VCHIQ display device
*
***************************************************************************/
#if defined(CONFIG_KONA_VCHIQ_MEMDRV) || defined(CONFIG_KONA_VCHIQ_MEMDRV_MODULE)

/*
 * Internal videocore using the vchiq_arm stack
 */

#define  VCHIQ_DISPLAY_DEVICE

#define IPC_SHARED_CHANNEL_VIRT     (KONA_INT_SRAM_BASE + BCMHANA_ARAM_VC_OFFSET)
#define IPC_SHARED_CHANNEL_PHYS     (INT_SRAM_BASE + BCMHANA_ARAM_VC_OFFSET)

static VCHIQ_PLATFORM_DATA_MEMDRV_KONA_T vchiq_display_data_memdrv_kona = {
	.memdrv = {
		.common = {
			.instance_name = "display",
			.dev_type      = VCHIQ_DEVICE_TYPE_SHARED_MEM,
		},
		.sharedMemVirt  = (void *)(IPC_SHARED_CHANNEL_VIRT),
		.sharedMemPhys  = IPC_SHARED_CHANNEL_PHYS,
	},
	.ipcIrq = BCM_INT_ID_IPC_OPEN,
};

static struct platform_device vchiq_display_device = {
	.name = "vchiq_memdrv_kona",
	.id = 0,
	.dev = {
		.platform_data = &vchiq_display_data_memdrv_kona,
	},
};

#elif defined(CONFIG_VC_VCHIQ_BUSDRV_SHAREDMEM) || defined(CONFIG_VC_VCHIQ_BUSDRV_SHAREDMEM_MODULE)

/*
 * Internal videocore using the vchiq stack.
 */

#define  VCHIQ_DISPLAY_DEVICE

static VCHIQ_PLATFORM_DATA_KONA_T vchiq_display_data_shared_mem = {
	.common = {
		.instance_name  = "display",
		.dev_type       = VCHIQ_DEVICE_TYPE_HOST_PORT,
	},
};

static struct platform_device vchiq_display_device = {
	.name = "vchiq_busdrv_sharedmem",
	.id = 0,
	.dev = {
		.platform_data = &vchiq_display_data_shared_mem,
	},
};

#endif

/****************************************************************************
*
*   VCEB framebuffer device
*
***************************************************************************/

#if defined(CONFIG_FB_VCEB) || defined(CONFIG_FB_VCEB_MODULE)

#define VCEB_FB_DEVICE

static struct platform_device vceb_fb_device = {
	.name = "vceb_fb",
	.id = -1,
};
#endif  /* CONFIG_FB_VCEB */

struct platform_device *vchiq_devices[] __initdata = {
#if defined(VCEB_DISPLAY_DEVICE)
	&vceb_display_device,
#endif
#if defined(VCHIQ_DISPLAY_DEVICE)
	&vchiq_display_device,
#endif
#if defined(VCEB_FB_DEVICE)
	&vceb_fb_device,
#endif
};

#endif  /* CONFIG_KONA_VCHIQ */


#if defined(CONFIG_SENSORS_BMA150) || defined(CONFIG_SENSORS_BMA150_MODULE)

#define board_bma150_axis_change concatenate(ISLAND_BOARD_ID, _bma150_axis_change)

#ifdef BMA150_DRIVER_AXIS_SETTINGS
static struct t_bma150_axis_change board_bma150_axis_change = BMA150_DRIVER_AXIS_SETTINGS;
#endif

static struct i2c_board_info __initdata i2c_bma150_info[] = {
	{
		I2C_BOARD_INFO(BMA150_DRIVER_NAME,
			       BMA150_DRIVER_SLAVE_NUMBER_0x38),
#ifdef BMA150_DRIVER_AXIS_SETTINGS
		.platform_data  = &board_bma150_axis_change,
#endif
	},
};
#endif

#if defined(CONFIG_SENSORS_AK8975) || defined(CONFIG_SENSORS_AK8975_MODULE) || \
	defined(CONFIG_SENSORS_AK8975_BRCM) || defined(CONFIG_SENSORS_AK8975_BRCM_MODULE)

#define board_akm8975_axis_change concatenate(ISLAND_BOARD_ID, _akm150_axis_change)

#ifdef AKM8975_DRIVER_AXIS_SETTINGS
static struct t_akm8975_axis_change board_akm8975_axis_change = AKM8975_DRIVER_AXIS_SETTINGS;
#endif

static struct i2c_board_info __initdata i2c_akm8975_info[] = {
	{
		I2C_BOARD_INFO(AKM8975_DRV_NAME, AKM8975_I2C_ADDR),
#ifdef AKM8975_DRIVER_AXIS_SETTINGS
		.platform_data  = &board_akm8975_axis_change,
#endif
	},
};
#endif /* CONFIG_SENSORS_AK8975 */


#if defined(CONFIG_SENSORS_BH1715) || defined(CONFIG_SENSORS_BH1715_MODULE)
static struct i2c_board_info __initdata i2c_bh1715_info[] = {
	{
		I2C_BOARD_INFO(BH1715_DRV_NAME, BH1715_I2C_ADDR),
	},
};
#endif

#if defined(CONFIG_SENSORS_MPU3050) || defined(CONFIG_SENSORS_MPU3050_MODULE)

#define board_mpu3050_data concatenate(ISLAND_BOARD_ID, _mpu3050_data)

#ifdef MPU3050_DRIVER_AXIS_SETTINGS
static struct t_mpu3050_axis_change board_mpu3050_axis_change = MPU3050_DRIVER_AXIS_SETTINGS;
#endif

static struct mpu3050_platform_data board_mpu3050_data = {
	.gpio_irq_pin = MPU3050_GPIO_IRQ_PIN,
	.scale        = MPU3050_SCALE,
#ifdef MPU3050_DRIVER_AXIS_SETTINGS
	.p_axis_change = &board_mpu3050_axis_change,
#else
	.p_axis_change = 0,
#endif
};

static struct i2c_board_info __initdata i2c_mpu3050_info[] = {
	{
		I2C_BOARD_INFO(MPU3050_DRV_NAME, MPU3050_I2C_ADDR),
		.platform_data  = &board_mpu3050_data,
	},
};
#endif

#if defined(CONFIG_MPU_SENSORS_MPU6050B1) || defined(CONFIG_MPU_SENSORS_MPU6050B1_MODULE)

#define mpu6050_platform_data concatenate(ISLAND_BOARD_ID, _mpu6050_data)

#ifdef MPU6050_DRIVER_ACCEL_GYRO_SETTINGS
static struct t_brcm_axis_change board_mpu6050_accel_gyro_change = MPU6050_DRIVER_ACCEL_GYRO_SETTINGS;
#endif

#ifdef MPU6050_DRIVER_COMPASS_SETTINGS
static struct t_brcm_axis_change board_mpu6050_compass_change = MPU6050_DRIVER_COMPASS_SETTINGS;
#endif

#ifdef MPU6050_DRIVER_REG_VALUES
static int mpu6060_reg_vals[] = MPU6050_DRIVER_REG_VALUES;
#endif

static struct t_brcm_sensors_axis_change board_mpu6050_sensors_change = {
	/* The MPU6050 is an accelerometer and a gyro. */
#ifdef MPU6050_DRIVER_ACCEL_GYRO_SETTINGS
	.p_accel_axis_change   = &board_mpu6050_accel_gyro_change,
	.p_gyro_axis_change    = &board_mpu6050_accel_gyro_change,
#else
	.p_accel_axis_change   = NULL,
	.p_gyro_axis_change    = NULL,
#endif

#ifdef MPU6050_DRIVER_COMPASS_SETTINGS
	.p_compass_axis_change = &board_mpu6050_compass_change,
#else
	.p_compass_axis_change = NULL,
#endif

#ifdef MPU6050_DRIVER_REG_VALUES
	.p_data = (void *) &mpu6060_reg_vals,
#else
	.p_data = NULL;
#endif
};

static struct mpu_platform_data mpu6050_platform_data = {
	.int_config  = MPU6050_INIT_CFG,
	/* gyro settings */
	.orientation = {0, -1, 0,
			-1, 0, 0,
			0, 0, -1 },
	/* accel settings */
	.accel = {
#if defined CONFIG_INV_SENSORS_MODULE
		.get_slave_descr = NULL,
#else
		.get_slave_descr = get_accel_slave_descr,
#endif
/*		.irq         not used */
		.adapt_num   = MPU6050_ADAPT_NUM,
		.bus         = EXT_SLAVE_BUS_PRIMARY,
		.address     = DEFAULT_MPU_SLAVEADDR,
		.orientation = {0, -1, 0,
				-1, 0, 0,
				0, 0, -1 },
		.private_data = (void *)&board_mpu6050_sensors_change,
	},
	/* compass settings */
	.compass = {

#if defined CONFIG_INV_SENSORS_MODULE
		.get_slave_descr = NULL,
#else
		.get_slave_descr = get_compass_slave_descr,
#endif
/*		.irq         not used */
		.adapt_num   = MPU6050_ADAPT_NUM,
		.bus         = EXT_SLAVE_BUS_SECONDARY,
		.address     = MPU6050_COMPASS_SLAVE_ADDR,
		.orientation = {1, 0, 0,
				0, 1, 0,
				0, 0, 1 },
	 },
};

static struct i2c_board_info __initdata i2c_mpu6050_info[] = {
	{
		I2C_BOARD_INFO(MPU_NAME, MPU6050_SLAVE_ADDR),
#ifdef MPU6050_ACCEL_GYRO_INT
	.irq = MPU6050_ACCEL_GYRO_INT,
#endif
		.platform_data  = &mpu6050_platform_data,
	},
};
#endif /* CONFIG_MPU_SENSORS_MPU6050B1 */

#if defined(CONFIG_BMP18X_I2C) || defined(CONFIG_BMP18X_I2C_MODULE)
static struct i2c_board_info __initdata i2c_bmp18x_info[] = {
	{
		I2C_BOARD_INFO(BMP18X_NAME, BMP18X_I2C_ADDRESS),
	},
};
#endif

#if defined(CONFIG_BCM_RFKILL) || defined(CONFIG_BCM_RFKILL_MODULE)
#define board_bcmbt_rfkill_cfg concatenate(ISLAND_BOARD_ID, _bcmbt_rfkill_cfg)
static struct bcmbt_rfkill_platform_data board_bcmbt_rfkill_cfg = {
#if defined(BCMBT_VREG_GPIO)
	.vreg_gpio = BCMBT_VREG_GPIO,
#else
	.vreg_gpio = -1,
#endif
	.n_reset_gpio = -1,
	.aux0_gpio = -1,
	.aux1_gpio = -1
};
#define board_bcmbt_rfkill_device concatenate(ISLAND_BOARD_ID, _bcmbt_rfkill_device)
static struct platform_device board_bcmbt_rfkill_device = {
	.name = "bcmbt-rfkill",
	.id = 1,
	.dev = {
		.platform_data = &board_bcmbt_rfkill_cfg,
	},
};

static void __init board_add_bcmbt_rfkill_device(void)
{
	platform_device_register(&board_bcmbt_rfkill_device);
}
#endif

#if defined(CONFIG_BCM_LPM_LDISC) || defined(CONFIG_BCM_LPM_LDISC_MODULE)
#define board_bcmbt_lpm_cfg concatenate(ISLAND_BOARD_ID, _bcmbt_lpm_cfg)
static struct bcmbt_lpm_ldisc_platform_data board_bcmbt_lpm_cfg = {
	.gpio_bt_wake = GPIO_BT_WAKE,
	.gpio_host_wake = GPIO_HOST_WAKE,
};
#define board_bcmbt_lpm_device concatenate(ISLAND_BOARD_ID, _bcmbt_lpm_device)
static struct platform_device board_bcmbt_lpm_device = {
	.name = "bcmbt-lpm-ldisc",
	.id = -1,
	.dev = {
		.platform_data = &board_bcmbt_lpm_cfg,
	},
};

static void __init board_add_bcmbt_lpm_device(void)
{
	platform_device_register(&board_bcmbt_lpm_device);
}
#endif

#if defined(CONFIG_MONITOR_ADC121C021_I2C) || defined(CONFIG_MONITOR_ADC121C021_I2C_MODULE)

#define board_adc121c021_i2c_param concatenate(ISLAND_BOARD_ID, _adc121c021_i2c_param)
static struct I2C_ADC121C021_t board_adc121c021_i2c_param;

#define board_adc121c021_i2c_boardinfo concatenate(ISLAND_BOARD_ID, _adc121c021_i2c_boardinfo)
static struct i2c_board_info board_adc121c021_i2c_boardinfo[] = {
	{
		.type = I2C_ADC121C021_DRIVER_NAME, /* "adc121c021_i2c_drvr" */
		.addr = I2C_ADC121C021_DRIVER_SLAVE_NUMBER, /* 0x54 */
		.platform_data = &board_adc121c021_i2c_param,
	},
};
#endif

#if defined(CONFIG_MONITOR_BQ27541_I2C) || defined(CONFIG_MONITOR_BQ27541_I2C_MODULE)
#define board_bq27541_i2c_boardinfo concatenate(ISLAND_BOARD_ID, _bq27541_i2c_boardinfo)
static struct i2c_board_info board_bq27541_i2c_boardinfo[] = {
	{
		.type = I2C_BQ27541_DRIVER_NAME, /* "bq27541_i2c_drvr" */
		.addr = I2C_BQ27541_DRIVER_SLAVE_NUMBER, /* 0x55 */
	},
};
#endif

#if defined(CONFIG_BATTERY_MAX17040) || defined(CONFIG_BATTERY_MAX17040_MODULE)
#define board_max17040_info concatenate(ISLAND_BOARD_ID, _max17040_info)
static struct max17040_platform_data board_max17040_info = {
	/*
	 * Function pointers used to discover battery or AC power status
	 * using GPIOs
	 */
	.battery_online = NULL,
	.charger_online = NULL,
	.charger_enable = NULL,

#if defined(CONFIG_BCM_CMP_BATTERY_MULTI) || defined(CONFIG_BCM_CMP_BATTERY_MULTI_MODULE)
	.gpio_ac_power = HW_MAX17040_GPIO_AC_POWER,
	.ac_power_on_level = HW_MAX17040_AC_POWER_ON_LEVEL,
	.gpio_charger = HW_MAX17040_GPIO_CHARGER,
	.battery_max_voltage = HW_BATTERY_MAX_VOLTAGE,
#endif
};

#define board_max17040_i2c_boardinfo concatenate(ISLAND_BOARD_ID, _max17040_i2c_boardinfo)
static struct i2c_board_info board_max17040_i2c_boardinfo[] = {
	{
		.type = HW_MAX17040_DRIVER_NAME,             /* "max17040" */
		.addr = HW_MAX17040_SLAVE_ADDR,              /* 0x36       */
		.platform_data = &board_max17040_info,
	},
};
#endif

#if defined(CONFIG_BCM_CMP_BATTERY_MULTI) || defined(CONFIG_BCM_CMP_BATTERY_MULTI_MODULE)
#define board_cmp_battery_multi_info concatenate(ISLAND_BOARD_ID, _board_cmp_battery_multi_info)
static struct cbm_platform_data board_cmp_battery_multi_info = CMP_BATTERY_MULTI_SETTINGS;

#define board_battery_multi concatenate(ISLAND_BOARD_ID, _board_battery_multi)
static struct platform_device board_battery_multi = {
	.name = HW_CMP_MULTI_DRIVER_NAME,
	.id = -1,
	.dev = {
		.platform_data = &board_cmp_battery_multi_info,
	},
};
#endif

#if defined(CONFIG_BCM_CMP_BATTERY_BQ24616) || defined(CONFIG_BCM_CMP_BATTERY_BQ24616_MODULE)
#define battery_bq24616_data concatenate(ISLAND_BOARD_ID, _battery_bq24616_data)
static struct battery_bq24616_cfg battery_bq24616_data = {
	.gpio_ctl_pwr = HW_BATTERY_CTL_PWR,
	.gpio_acp_shd = HW_BATTERY_ACP_SHDN,
	.gpio_docking_station_power_3_3v = GPIO_DOCKING_STATION_POWER_3_3V,
};

#define board_battery_bq24616 concatenate(ISLAND_BOARD_ID, _board_battery_bq24616)
static struct platform_device board_battery_bq24616 = {
	.name = "cmp-battery",
	.id = -1,
	.dev = {
		.platform_data = &battery_bq24616_data,
	},
};
#endif

static void __init add_sdio_device(void)
{
	unsigned int i, id, num_devices;

	num_devices = ARRAY_SIZE(sdio_param);
	if (num_devices > MAX_SDIO_DEVICES)
		num_devices = MAX_SDIO_DEVICES;

	/*
	 * Need to register eMMC as the first SDIO device so it grabs mmcblk0
	 * when it's installed. This required for rootfs to be mounted properly
	 *
	 * Ask Darwin for why we need to do this
	 */
	for (i = 0; i < num_devices; i++) {
		id = sdio_param[i].id;
		if (id < MAX_SDIO_DEVICES) {
			if (sdio_param[i].devtype == SDIO_DEV_TYPE_EMMC) {
				sdio_devices[id].dev.platform_data = &sdio_param[i];
				platform_device_register(&sdio_devices[id]);
			}
		}
	}

	for (i = 0; i < num_devices; i++) {
		id = sdio_param[i].id;

		/* skip eMMC as it has been registered */
		if (sdio_param[i].devtype == SDIO_DEV_TYPE_EMMC)
			continue;

		if (id < MAX_SDIO_DEVICES) {
			if (sdio_param[i].devtype == SDIO_DEV_TYPE_WIFI) {
				struct sdio_wifi_gpio_cfg *wifi_gpio =
						&sdio_param[i].wifi_gpio;

#ifdef HW_WLAN_GPIO_RESET_PIN
				wifi_gpio->reset = HW_WLAN_GPIO_RESET_PIN;
#else
				wifi_gpio->reset = -1;
#endif
#ifdef HW_WLAN_GPIO_SHUTDOWN_PIN
				wifi_gpio->shutdown = HW_WLAN_GPIO_SHUTDOWN_PIN;
#else
				wifi_gpio->shutdown = -1;
#endif
#ifdef HW_WLAN_GPIO_REG_PIN
				wifi_gpio->reg = HW_WLAN_GPIO_REG_PIN;
#else
				wifi_gpio->reg = -1;
#endif
#ifdef HW_WLAN_GPIO_HOST_WAKE_PIN
				wifi_gpio->host_wake = HW_WLAN_GPIO_HOST_WAKE_PIN;
#else
				wifi_gpio->host_wake = -1;
#endif
			}
			sdio_devices[id].dev.platform_data = &sdio_param[i];
			platform_device_register(&sdio_devices[id]);
		}
	}
}

static void __init add_i2c_device(void)
{
	unsigned int i, num_devices;

	num_devices = ARRAY_SIZE(i2c_adap_param);
	if (num_devices == 0)
		return;
	if (num_devices > MAX_I2C_ADAPS)
		num_devices = MAX_I2C_ADAPS;

	for (i = 0; i < num_devices; i++) {
		/* DO NOT register the I2C device if it is disabled */
		if (i2c_adap_param[i].disable == 1)
			continue;

		i2c_adap_devices[i].dev.platform_data = &i2c_adap_param[i];
		platform_device_register(&i2c_adap_devices[i]);
	}

#if defined(CONFIG_TOUCHSCREEN_EGALAX_I2C) || defined(CONFIG_TOUCHSCREEN_EGALAX_I2C_MODULE)
#ifdef HW_EGALAX_I2C_BUS_ID
	egalax_i2c_param.id = HW_EGALAX_I2C_BUS_ID;
#endif

#ifdef HW_EGALAX_GPIO_RESET
	egalax_i2c_param.gpio.reset = HW_EGALAX_GPIO_RESET;
#endif

#ifdef HW_EGALAX_GPIO_EVENT
	egalax_i2c_param.gpio.event = HW_EGALAX_GPIO_EVENT;
#endif

	egalax_i2c_boardinfo[0].irq =
		gpio_to_irq(egalax_i2c_param.gpio.event);

	i2c_register_board_info(egalax_i2c_param.id, egalax_i2c_boardinfo,
		ARRAY_SIZE(egalax_i2c_boardinfo));
#endif

#if defined(CONFIG_SENSORS_BMA150) || defined(CONFIG_SENSORS_BMA150_MODULE)

	i2c_register_board_info(
#ifdef SENSORS_BMA150_I2C_BUS_ID
		SENSORS_BMA150_I2C_BUS_ID,
#else
		-1,
#endif
		i2c_bma150_info, ARRAY_SIZE(i2c_bma150_info));
#endif

#if defined(CONFIG_SENSORS_BH1715) || defined(CONFIG_SENSORS_BH1715_MODULE)
	i2c_register_board_info(
#ifdef BH1715_I2C_BUS_ID
		BH1715_I2C_BUS_ID,
#else
		-1,
#endif
		i2c_bh1715_info, ARRAY_SIZE(i2c_bh1715_info));
#endif

#if defined(CONFIG_SENSORS_MPU3050) || defined(CONFIG_SENSORS_MPU3050_MODULE)
	i2c_register_board_info(
#ifdef MPU3050_I2C_BUS_ID
		MPU3050_I2C_BUS_ID,
#else
		-1,
#endif
		i2c_mpu3050_info, ARRAY_SIZE(i2c_mpu3050_info));
#endif

#if defined(CONFIG_MPU_SENSORS_MPU6050B1) || defined(CONFIG_MPU_SENSORS_MPU6050B1_MODULE)
	i2c_register_board_info(MPU6050_I2C_BUS_ID,
				i2c_mpu6050_info, ARRAY_SIZE(i2c_mpu6050_info));
#endif

#if defined(CONFIG_SENSORS_AK8975) || defined(CONFIG_SENSORS_AK8975_MODULE) \
	|| defined(CONFIG_SENSORS_AK8975_BRCM) || defined(CONFIG_SENSORS_AK8975_BRCM_MODULE)
	i2c_register_board_info(
#ifdef AKM8975_I2C_BUS_ID
		AKM8975_I2C_BUS_ID,
#else
		-1,
#endif
		i2c_akm8975_info, ARRAY_SIZE(i2c_akm8975_info));
#endif


#if defined(CONFIG_BMP18X_I2C) || defined(CONFIG_BMP18X_I2C_MODULE)
	i2c_register_board_info(
#ifdef BMP18X_I2C_BUS_ID
		BMP18X_I2C_BUS_ID,
#else
		-1,
#endif
		i2c_bmp18x_info, ARRAY_SIZE(i2c_bmp18x_info));
#endif

#if defined(CONFIG_MONITOR_ADC121C021_I2C)  || defined(CONFIG_MONITOR_ADC121C021_I2C_MODULE)
	board_adc121c021_i2c_param.id                  = HW_ADC121C021_I2C_BUS_ID;
	board_adc121c021_i2c_param.gpio_irq_pin        = HW_ADC121C021_GPIO_EVENT;
	board_adc121c021_i2c_param.num_bytes_to_read   = HW_ADC121C021_BYTES_TO_READ;
	board_adc121c021_i2c_param.i2c_slave_address   = I2C_ADC121C021_DRIVER_SLAVE_NUMBER;
	board_adc121c021_i2c_param.battery_max_voltage = HW_BATTERY_MAX_VOLTAGE;
	board_adc121c021_i2c_param.battery_min_voltage = HW_BATTERY_MIN_VOLTAGE;
	board_adc121c021_i2c_param.resistor_1          = HW_ADC121C021_RESISTOR_1;
	board_adc121c021_i2c_param.resistor_2          = HW_ADC121C021_RESISTOR_2;

#if defined(CONFIG_BCM_CMP_BATTERY_MULTI) || defined(CONFIG_BCM_CMP_BATTERY_MULTI_MODULE)
	board_adc121c021_i2c_param.gpio_ac_power       = HW_ADC121C021_GPIO_AC_POWER;
	board_adc121c021_i2c_param.ac_power_on_level   = HW_ADC121C021_AC_POWER_ON_LEVEL;
	board_adc121c021_i2c_param.gpio_charger        = HW_ADC121C021_GPIO_CHARGER;
#endif

	printk(KERN_INFO "board_template.c %s() IRQ pin %d\n",
		__func__,
		board_adc121c021_i2c_param.gpio_irq_pin);
	board_adc121c021_i2c_boardinfo[0].irq =
			gpio_to_irq(board_adc121c021_i2c_param.gpio_irq_pin);

	i2c_register_board_info(board_adc121c021_i2c_param.id,
				board_adc121c021_i2c_boardinfo,
				ARRAY_SIZE(board_adc121c021_i2c_boardinfo));
#endif

#if defined(CONFIG_MONITOR_BQ27541_I2C) || defined(CONFIG_MONITOR_BQ27541_I2C_MODULE)
	i2c_register_board_info(HW_BQ27541_I2C_BUS_ID,
				board_bq27541_i2c_boardinfo,
				ARRAY_SIZE(board_bq27541_i2c_boardinfo));
#endif

#if defined(CONFIG_BATTERY_MAX17040) || defined(CONFIG_BATTERY_MAX17040_MODULE)
	i2c_register_board_info(HW_MAX17040_I2C_BUS_ID,
				board_max17040_i2c_boardinfo,
				ARRAY_SIZE(board_max17040_i2c_boardinfo));
#endif

}

#if defined(CONFIG_LEDS_GPIO) || defined(CONFIG_LEDS_GPIO_MODULE)
#define board_add_led_device concatenate(ISLAND_BOARD_ID, _add_led_device)
static void __init board_add_led_device(void)
{
	platform_device_register(&board_leds_gpio_device);
}
#endif

#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
#define board_add_keys_device concatenate(ISLAND_BOARD_ID, _add_keyboard_device)
static void __init board_add_keys_device(void)
{
	platform_device_register(&board_gpio_keys_device);
}
#endif

#if defined(CONFIG_KEYBOARD_KONA) || defined(CONFIG_KEYBOARD_KONA_MODULE)
#define board_add_keyboard_kona concatenate(ISLAND_BOARD_ID, _add_keyboard_kona)
static void __init board_add_keyboard_kona(void)
{
	platform_device_register(&board_keypad_device);
}
#endif


static void __init add_usbh_device(void)
{
	/*
	 * Always register the low level USB host device before EHCI/OHCI
	 * devices. Also, always add EHCI device before OHCI
	 */
	platform_device_register(&usbh_device);
	platform_device_register(&usbh_ehci_device);
	platform_device_register(&usbh_ohci_device);
}

static void __init add_usb_otg_device(void)
{
#if defined(CONFIG_KONA_OTG_CP) || defined(CONFIG_KONA_OTG_CP_MODULE)
	platform_device_register(&otg_cp_device);
#endif

#if defined(CONFIG_MAX3353) || defined(CONFIG_MAX3353_MODULE)
#ifdef HW_OTG_MAX3353_I2C_BUS_ID
	max3353_info.id = HW_OTG_MAX3353_I2C_BUS_ID;
#else
	max3353_info.id = -1;
#endif
#ifdef HW_OTG_MAX3353_GPIO_INT
	max3353_info.irq_gpio_num = HW_OTG_MAX3353_GPIO_INT;
#else
	max3353_info.irq_gpio_num = -1;
#endif
	i2c_register_board_info(max3353_info.id,
				max3353_i2c_boardinfo,
				ARRAY_SIZE(max3353_i2c_boardinfo));
#endif
}

#define board_halaudio_dev_list concatenate(ISLAND_BOARD_ID, _halaudio_dev_list)
static HALAUDIO_DEV_CFG board_halaudio_dev_list[] =
#ifdef HALAUDIO_DEV_LIST
	HALAUDIO_DEV_LIST;
#else
	NULL;
#endif

#define board_halaudio_cfg concatenate(ISLAND_BOARD_ID, _halaudio_cfg)
static HALAUDIO_CFG board_halaudio_cfg;

#define board_halaudio_device concatenate(ISLAND_BOARD_ID, _halaudio_device)
static struct platform_device board_halaudio_device = {
	.name = "bcm-halaudio",
	.id = -1, /* to indicate there's only one such device */
	.dev = {
		.platform_data = &board_halaudio_cfg,
	},
};

#define board_halaudio_audio_info concatenate(ISLAND_BOARD_ID, _halaudio_audioh_info)
static HALAUDIO_AUDIOH_PLATFORM_INFO board_halaudio_audioh_info = {
	.spk_en_gpio = {
#ifdef HALAUDIO_AUDIOH_SETTINGS_GPIO_HANDSFREE_LEFT_EN
		.handsfree_left_en = HALAUDIO_AUDIOH_SETTINGS_GPIO_HANDSFREE_LEFT_EN,
#else
		.handsfree_left_en = -1,
#endif
#ifdef HALAUDIO_AUDIOH_SETTINGS_GPIO_HANDSFREE_RIGHT_EN
		.handsfree_right_en = HALAUDIO_AUDIOH_SETTINGS_GPIO_HANDSFREE_RIGHT_EN,
#else
		.handsfree_right_en = -1,
#endif

#ifdef HALAUDIO_AUDIOH_SETTINGS_GPIO_HEADSET_EN
		.headset_en = HALAUDIO_AUDIOH_SETTINGS_GPIO_HEADSET_EN,
#else
		.headset_en = -1,
#endif
	},

#ifdef HALAUDIO_AUDIOH_SETTINGS_EARPIECE_SPARE_BIT_EN
	.earpiece_spare_bit_en = HALAUDIO_AUDIOH_SETTINGS_EARPIECE_SPARE_BIT_EN,
#else
	.earpiece_spare_bit_en = 1,
#endif

};

#define board_halaudio_audioh_device concatenate(ISLAND_BOARD_ID, _halaudio_audioh_device)
static struct platform_device board_halaudio_audioh_device = {
	.name = "bcm-halaudio-audioh",
	.id = -1, /* to indicate there's only one such device */
	.dev = {
		.platform_data = &board_halaudio_audioh_info,
	},
};

#define board_halaudio_pcm_info concatenate(ISLAND_BOARD_ID, _halaudio_pcm_info)
static HALAUDIO_PCM_PLATFORM_INFO board_halaudio_pcm_info = {
#ifdef HALAUDIO_PCM_SETTINGS_CORE_ID_SELECT
	.core_id_select = HALAUDIO_PCM_SETTINGS_CORE_ID_SELECT,
#else
	.core_id_select = -1,
#endif
#ifdef HALAUDIO_PCM_SETTINGS_CHANS_SUPPORTED
	.channels = HALAUDIO_PCM_SETTINGS_CHANS_SUPPORTED,
#endif
#ifdef HALAUDIO_PCM_SETTINGS_CHAN_SELECT
	.channel_select = HALAUDIO_PCM_SETTINGS_CHAN_SELECT,
#endif
	.bt_gpio = {
#ifdef HALAUDIO_PCM_SETTINGS_GPIO_BT_RST_B
		.rst_b = HALAUDIO_PCM_SETTINGS_GPIO_BT_RST_B,
#else
		.rst_b = -1,
#endif
#ifdef HALAUDIO_PCM_SETTINGS_GPIO_BT_VREG_CTL
		.vreg_ctl = HALAUDIO_PCM_SETTINGS_GPIO_BT_VREG_CTL,
#else
		.vreg_ctl = -1,
#endif
#ifdef HALAUDIO_PCM_SETTINGS_GPIO_BT_WAKE
		.wake = HALAUDIO_PCM_SETTINGS_GPIO_BT_WAKE,
#else
		.wake = -1,
#endif
	},
#ifdef HALAUDIO_PCM_SETTINGS_BT_REQ_UART_GPIO_GROUP
	.bt_req_uart_gpio_group = HALAUDIO_PCM_SETTINGS_BT_REQ_UART_GPIO_GROUP,
#else
	.bt_req_uart_gpio_group = -1,
#endif
};

#ifndef HALAUDIO_PCM_SETTINGS_GPIO_BT_RST_B
#define BT_SUPPORT    0
#else
#define BT_SUPPORT    1
#endif

#define board_halaudio_pcm_device concatenate(ISLAND_BOARD_ID, _halaudio_pcm_device)
static struct platform_device board_halaudio_pcm_device = {
	.name = "bcm-halaudio-pcm",
	.id = -1, /* to indicate there's only one such device */
	.dev = {
		.platform_data = &board_halaudio_pcm_info,
	},
};

#define board_add_halaudio_device concatenate(ISLAND_BOARD_ID, _add_halaudio_device)
static void __init board_add_halaudio_device(void)
{
	board_halaudio_cfg.numdev = ARRAY_SIZE(board_halaudio_dev_list);
	board_halaudio_cfg.devlist = board_halaudio_dev_list;
	platform_device_register(&board_halaudio_device);
	platform_device_register(&board_halaudio_audioh_device);
	platform_device_register(&board_halaudio_pcm_device);
}

static void __init add_devices(void)
{
#if defined(CONFIG_BACKLIGHT_PWM) || defined(CONFIG_BACKLIGHT_PWM_MODULE)
	platform_device_register(&pwm_backlight_device);
#endif

#ifdef HW_SDIO_PARAM
	add_sdio_device();
#endif

#ifdef HW_I2C_ADAP_PARAM
	add_i2c_device();
#endif

#if defined(CONFIG_LEDS_GPIO) || defined(CONFIG_LEDS_GPIO_MODULE)
	board_add_led_device();
#endif

#if defined(CONFIG_BCM_HEADSET_SW)
	board_add_headsetdet_device();
#endif

#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
	board_add_keys_device();
#endif

#if defined(CONFIG_KEYBOARD_KONA) || defined(CONFIG_KEYBOARD_KONA_MODULE)
	board_add_keyboard_kona();
#endif

#if defined(CONFIG_BCM_RFKILL) || defined(CONFIG_BCM_RFKILL_MODULE)
	board_add_bcmbt_rfkill_device();
#endif

#if defined(CONFIG_BCM_LPM_LDISC) || defined(CONFIG_BCM_LPM_LDISC_MODULE)
	board_add_bcmbt_lpm_device();
#endif

#if defined(CONFIG_BCM_CMP_BATTERY_MULTI) || defined(CONFIG_BCM_CMP_BATTERY_MULTI_MODULE)
	platform_device_register(&board_battery_multi);
#endif

#if defined(CONFIG_BCM_CMP_BATTERY_BQ24616) || defined(CONFIG_BCM_CMP_BATTERY_BQ24616_MODULE)
	platform_device_register(&board_battery_bq24616);
#endif

#if defined(CONFIG_BCM_HAPTICS) || defined(CONFIG_BCM_HAPTICS_MODULE)
	platform_device_register(&board_bcm_haptics_device);
#endif

	add_usbh_device();
	add_usb_otg_device();

#if defined(CONFIG_BCM_HDMI_DET) || defined(CONFIG_BCM_HDMI_DET_MODULE)
	board_add_hdmidet_device();
#endif

#if defined(CONFIG_TFT_PANEL) || defined(CONFIG_TFT_PANEL_MODULE)
	board_add_tft_panel_device();
#endif

	board_add_halaudio_device();

#ifdef CONFIG_NET_ISLAND
	platform_device_register(&net_device);
#endif

#if defined(CONFIG_BCM_GPS) || defined(CONFIG_BCM_GPS_MODULE)
	platform_device_register(&platform_device_gps);
#endif

#if defined(CONFIG_KONA_VCHIQ) || defined(CONFIG_KONA_VCHIQ_MODULE)
	platform_add_devices(vchiq_devices, ARRAY_SIZE(vchiq_devices));
#endif
}

static void __init board_init(void)
{
#ifdef CONFIG_MAP_SDMA
	dma_mmap_init();
	sdma_init();
#endif

#ifdef CONFIG_MAP_LITTLE_ISLAND_MEMC_QOS
	memc_qos_init();
#endif
	/*
	 * Add common platform devices that do not have board dependent HW
	 * configurations
	 */
	board_add_common_devices();

	/* add devices with board dependent HW configurations */
	add_devices();
}

/*
 * Template used by board-xxx.c to create new board instance
 */
#define CREATE_BOARD_INSTANCE(id, name) \
MACHINE_START(id, name) \
	.map_io = island_map_io, \
	.init_irq = kona_init_irq, \
	.timer  = &kona_timer, \
	.init_machine = board_init, \
MACHINE_END
